<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>W2 | 첫 시험 그런데 동기들이 너무 어려요 – It’s Bona-behind</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">It’s Bona-behind</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.instagram.com/itsbonabehind/"> <i class="bi bi-instagram" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">W2 | 첫 시험 그런데 동기들이 너무 어려요</h1>
  <div class="quarto-categories">
    <div class="quarto-category">blog</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>화요일에 선수과목 &lt; R 프로그래밍 입문 &gt; 과 &lt; 기초통계학 &gt; 시험을 봤다. 금요일부터는 시험 당일까지 서너 시간만 자면서 밤을 샜다. 시험을 잘 보고 싶은데 잘 될 것 같지 않아서 애가 탔다. 같은 반 동기들 중에는 기존에 R을 약간이라도 써 본 경험이 있거나 아예 통계학을 부전공한 경우도 더러 있어서 몹시 걱정스러웠다(왜냐면 나는 둘 다 전혀 아니었으니까). 이번 시험은 pass/fail 여부만 남지만 그래도 중간 이상은 하고 싶었는데.. 신기했던 것은 언젠가 만들어진 자료 공유용 구글 드라이브에 너도 나도 할 것 없이 자신의 필기나 강의 요약본, 각자 공부하면서 도움이 되었던 자료들을 기꺼이 공유하는 동기들의 모습이었다. 그룹챗에서는 어떤 문제가 나올까 서로 예측해보기도 하면서 각자가 이해하고 있는 방식이나 단계 정도를 예측할 수 있었다. 이런 분위기나 문화가 여기에서는 얼마나 자연스러운 것인지 모르겠으나 시험이라면 상대평가가 전부인 시스템 아래에서 자란 나로서는 꽤 신선하고 긍정적인 충격이었다.</p>
<p>이 자료 공유가 없었다면 상상만 해도 아찔한 것이 시험 전날 새벽 누군가 작년에 같은 교수님의 &lt; R 프로그래밍 입문 &gt; 수업을 들었던 지인으로부터 받은 기출문제를 공유했다. 자료에는 dataset부터 문제, 코딩 답안이 전부 포함되어 있었는데 올해 시험에서도 동일한 dataset을 썼고 총 여덟 문제 중 다섯 문제가 거의 동일했다. 완전한 오픈북 시험이긴 했지만 (강의 슬라이드, 필기 내용, 구글링, chatGPT 등 AI 사용까지 모두 가능했다. 이게 가능했던 것은 12시간 동안 다룬 함수의 종류가 워낙 한정적이다 보니 작성한 코드만 봐도 강의한 내용에 기초해서 본인이 오롯이 풀었는지 아니면 어디에 기대서 풀었는지 너무 쉽게 눈에 띄었기 때문이다. 물론 이게 pass/fail을 위한 선수과목이라는 특성상 다른 것에 기대서 풀었다고 해서 점수에 영향이 있는 것도 아니었다.) 그래도 내가 작년 기출문제를 풀지 않았더라면 그 다섯 문제들을 그렇게 빨리 풀 수 있었을까 싶었고.. 남은 세 문제 중에서는 한 문제를 제대로 풀지 못하고 답안을 제출했다.</p>
<p>&lt; 기초 통계학 &gt; 시험은 우리 모두를 식겁하게 만들었다. A4용지 한 면에 수기로 작성한 cheat-sheet와 계산기만 허용되는 수기 시험이었는데 총 여섯 문제가 나왔다. 각 문제는 두 개부터 여섯 개 정도 되는 하위 문제로 구성되어 있었다. 시험을 마치고 건물 앞에 우르르 모인 우리들 사이로 나타난 교수님께서는 ’문제가 정말 쉽지 않았냐’고 하셨지만 (너스레의 느낌이 전혀 아니었음. - 우리에 대한 기대치가 높으셨거나 또는 과대평가를 하신 것이 분명하게도 - 교수님은 그저 순수한 마음으로 그렇게 말하신 것 같았다.) 정말이지 대부분 fail을 걱정하고 있었다. 가장 쉬웠던 다양한 통계량을 계산하는 첫번째 문제는 숫자가 딱 떨어지지 않아서 ’이게 맞나..?’하면서 시간을 꽤 많이 쓰게 되었고 어떤 문제는 도저히 함수로 풀이를 적을 자신이 없어서 그림을(?) 그렸다. 두 문제는 아예 아무런 답을 못 적어냈다. 갑갑했다. 교수님들은 ’최악의 경우라고 해도 재시험을 보는 수준이다’고 하셨지만.. 재시험은 둘째 치고 내가 다음 통계학 수업을 잘 따라갈 수 있을까 겁이 났다.</p>
<p>&lt; R 프로그래밍 입문 &gt; 점수는 예상보다 빨리 목요일 아침에 나왔다. 100점 만점 중에 86점. 제대로 풀지 못한 문제 하나로 10점이 깎이고 풀이 중에 실수를 한 함수가 하나 있어서 4점이 차등 감점되지 않았나 싶다. 개별 코멘트를 받은 학생 한두 명은 수업이 끝나고 찾아오길 바란다는 교수님을 말을 보아서도, 프로그래밍 수업에 온 친구들의 표정만 보아서도 다들 큰 무리 없이 괜찮은 점수를 받은 것 같았다. 이번주가 다 가도록 &lt; 기초 통계학 &gt; 점수는 아직 나오지 않았으니 월요일까지 기다려 봐야 할 듯 싶다.</p>
<p>여하튼 선수과목 일정은 이렇게 시험으로 끝이 났고 곧장 9월 10일 수요일부터 1학기 개강을 했다. &lt; 데이터 시각화(Data Visualization) &gt;, &lt; 데이터 프로그래밍(Data Programming) &gt;, &lt; 전산사회과학의 기초(Foundation of Computational Social Science) &gt; 세 과목의 첫 수업이 있었다. R로 이렇게 많은 것을 할 수 있는 줄 정말 몰랐고 드디어 수학이 아닌 사회과학의 영역에 있는 주제들을 다루는 수업이 시작되어서 모두가 눈을 반짝였다. 물론 온갖 과제와 시험 일정도 함께 쏟아졌다. 개인 프로젝트, 페이퍼, 코딩 과제, 조별 발표 등으로 종류가 다양했다. 다음주에 두 과목 개강이 더 기다리고 있으니까 정신을 똑바로 차려야겠다고 생각했다. 학비를 일 년만 내서 좋았는데.. 몸과 뇌는 두 배 정도 더 고생하는 코스였다는 것을 새삼 깨달았다.</p>
<p>금요일에는 학과 웰컴 이벤트가 있었다. 감각을 통한 신체 인식에 대한 연구를 하신 교수님께서 40분 정도 간단한 강연을 해주셨고 나머지 시간에는 지하 카페테리아에서 다과 시간을 가졌다. 분명 이메일에는 ’칵테일’이라고 했지만 각종 논알콜 소프트 드링크와 각종 치즈, 크래커, 보까디요, 컵과일 등 전형적인 현지 핑거푸드로 구성되어 있었다. 벌써 개강하고 2주가 끝났으니 거의 대부분과 안면이 있었지만 처음 말을 나눠보는 동기들도 있었다. 이탈리아, 호주, 시리아, 대만, 미국, 칠레, 아르헨티나, 터키 등 생각보다 다른 나라에서 오직 이 코스를 위해 마드리드에 온 국제학생들이 정말 많았고, 현재 재직자이거나 풀타임으로 일해 본 경험이 있는 경우는 열 명이 채 안 되는 것 같았다. 보통 스물셋, 스물넷 - 학부를 마치고서 바로 또는 갭이어를 잠시 가지고 온 경우였다.</p>
<p>회사를 다닐 때는 주로 다음 휴가지와 요즘 열심히 하고 있는 운동에 대해서 이야기했다. 대출을 껴서 집을 사고 싶은데 언제까지 기다려야할지 모르겠다거나 결혼 준비에 대책 없이 돈을 얼마나 쏟아붓고 있는지 걱정했고 일이 많아서 치일 때에는 다음 연봉협상까지 기다려보자며 서로를 응원했다. 여기에서는 아무도 그런 이야기를 하지 않았다. 동기들은 생각보다 학교 런치메뉴가 저렴하지 않다고 얘기했고 유명한 체인 샐러드 카페에 가서 저녁을 먹고 싶어했으며 주말에는 무료로 갈 수 있는 근교도시들에 대한 계획을 나누고 있었다. 상반된 감정이 동시에 일었다. ’해봐야 알지 않냐’며 제법 치기 어린 생각으로 이십대 내내 열심히도 헤매고, 눈에 차고 손에 닿을 만한 것들 사이에서 크고 작은 결정들을 내리며, 한편으로는 큰 돈이지만 또 어쩌면 아무것도 아닌 돈을 모아, 간신히 스물아홉이 되어서야 나는 도착한 곳이니까. 누군가에게는 그저 짧게 스쳐 지나갈 이 도시가 나에게는 새로이 살아가기로 선택한 공간이고, 또 누군가에게는 그저 학부의 연장선일지 모르는 이 코스가 나에게는 버젓한 직장을 그만두고 선택한 일종의 절박함이니까. 그럼에도 나는 내가 그 모든 일을 하나하나 겪어온 것들이 전혀 아쉽지도 부끄럽지도 않다. 조금 늦은 것 같아보여도 그래서 천천히 여기까지 온 것이 자랑스럽다. 그리고 이렇게 내 과거와 현재를 긍정하는 일이 곧 내 미래를 긍정하는 것과 맞닿아 있을 거라고 굳게 믿는다.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/jueunbonalee\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>